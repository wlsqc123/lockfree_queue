# MutexQueue 구현 분석

## 개요
`MutexQueue`는 성능 비교를 위해 구현된 Two-Lock 기반의 Blocking Queue입니다. `MPMCQueue`와의 공정한 비교를 위해 동일한 메모리 레이아웃과 인터페이스를 가지도록 설계되었습니다.

## 핵심 구조

### 1. Two-Lock 알고리즘
```cpp
alignas(lfq::CACHE_LINE_SIZE) std::mutex m_tail_mutex;
std::atomic<size_t> m_tail;

alignas(lfq::CACHE_LINE_SIZE) std::mutex m_head_mutex;
std::atomic<size_t> m_head;
```
- **독립적인 잠금**: Push 연산은 `m_tail_mutex`를, Pop 연산은 `m_head_mutex`를 사용합니다. 이를 통해 생산자(Producer)와 소비자(Consumer)가 동시에 큐에 접근할 수 있어 단일 잠금(Single Lock) 방식보다 높은 병렬성을 제공합니다.
- **Padding**: 각 Mutex와 관련 변수들은 `alignas(lfq::CACHE_LINE_SIZE)`로 패딩되어 있어, 서로 다른 캐시 라인을 사용합니다. 이는 Push와 Pop 스레드 간의 캐시 경합(False Sharing)을 방지합니다.

### 2. 슬롯 (Slot)
```cpp
struct Slot
{
    size_t _dummy_generation;  // 메모리 레이아웃 맞추기용 (사용 안함)
    T _data;
};
```
- `MPMCQueue`의 `Slot` 구조체와 크기 및 레이아웃을 동일하게 맞추기 위해 `_dummy_generation` 멤버를 포함했습니다. 이는 벤치마크 시 캐시 적중률이나 메모리 대역폭 사용량 등에서 공정한 비교를 하기 위함입니다.

## 알고리즘 상세

### Push 동작
1. `m_tail_mutex`를 획득(Lock)합니다.
2. 큐가 가득 찼는지 확인합니다 (`_tail - _head >= Size`).
   - 가득 찼다면 Lock을 해제하고 `false`를 반환합니다.
3. 데이터를 버퍼에 복사합니다.
4. `m_tail`을 증가시킵니다.
5. Lock을 해제합니다.

### Pop 동작
1. `m_head_mutex`를 획득(Lock)합니다.
2. 큐가 비었는지 확인합니다 (`_head == _tail`).
   - 비었다면 Lock을 해제하고 `false`를 반환합니다.
3. 데이터를 버퍼에서 이동(Move)시킵니다.
4. `m_head`를 증가시킵니다.
5. Lock을 해제합니다.

## 성능 특성
- **장점**: 구현이 간단하고 직관적입니다. Two-Lock 사용으로 단일 Lock보다는 성능이 좋습니다.
- **단점**:
    - **Lock Overhead**: Mutex 획득/해제 시 운영체제 수준의 오버헤드가 발생할 수 있습니다.
    - **Blocking**: Lock을 획득하지 못한 스레드는 대기 상태로 전환(Context Switch)될 수 있어, Lock-Free 방식에 비해 지연 시간이 길어질 수 있습니다.
    - **Convoy Effect**: Lock을 보유한 스레드가 스케줄링에서 밀려나면 다른 스레드들이 줄줄이 대기하는 현상이 발생할 수 있습니다.

## MPMCQueue와의 비교
벤치마크 결과 `MutexQueue`는 `MPMCQueue`보다 느린 성능을 보였습니다. 이는 Mutex로 인한 동기화 비용과 컨텍스트 스위칭 오버헤드가 Lock-Free 알고리즘의 CAS 연산 비용보다 크기 때문입니다. 하지만 Two-Lock 구조와 패딩 최적화를 통해 일반적인 `std::mutex` 하나를 쓰는 큐보다는 훨씬 최적화된 성능을 보여줍니다.
